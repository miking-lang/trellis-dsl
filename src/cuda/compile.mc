-- Defines the compilation from the Trellis model AST to CUDA.

include "graph.mc"
include "mexpr/info.mc"

include "../src-loc.mc"
include "../trellis-arg.mc"
include "../constraints/predecessors.mc"
include "../model/ast.mc"
include "../model/encode.mc"
include "../model/merge-subseq-ops.mc"
include "../model/reduce-tables.mc"
include "ast.mc"
include "pprint.mc"

-- Type-related identifiers used in typedefs
let uint8 = nameSym "uint8_t"
let uint16 = nameSym "uint16_t"
let uint32 = nameSym "uint32_t"
let uint64 = nameSym "uint64_t"
let stateTyId = nameSym "state_t"
let obsTyId = nameSym "obs_t"
let probTyId = nameSym "prob_t"

-- Identifiers used in macros
let batchSizeId = nameSym "BATCH_SIZE"
let batchOverlapId = nameSym "BATCH_OVERLAP"
let numStatesId = nameSym "NUM_STATES"
let numObsId = nameSym "NUM_OBS"
let numPredsId = nameSym "NUM_PREDS"

-- Identifiers of functions used by the pre-defined parts of the code.
let initProbFunId = nameSym "init_prob"
let outProbFunId = nameSym "output_prob"
let forwProbPredsFunId = nameSym "forward_prob_predecessors"
let viterbiMaxPredsFunId = nameSym "viterbi_max_predecessor"

-- Identifiers used in the predecessor-specific code, reused for simplicity and
-- readability of output code
let stateId = nameSym "state"
let predId = nameSym "pred"
let probId = nameSym "p"

let cinfo = infoVal "Generated by 'src/cuda/compile.mc'" 0 0 0 0

let var = lam id. use TrellisCudaAst in CEVar {id = id}
let uop = lam op. lam arg. use TrellisCudaAst in CEUnOp {op = op, arg = arg}
let bop = lam op. lam l. lam r.
  use TrellisCudaAst in
  CEBinOp {op = op, lhs = l, rhs = r}

lang TrellisCudaCompileBase =
  TrellisModelAst + TrellisCudaAst + TrellisModelPredecessorAnalysis

  type CuCompileEnv = {
    -- Maps the index of each case of the transition probability function to
    -- its representation.
    constraints : [ConstraintRepr],

    -- A sequence of sets representing the indices of constraints that should
    -- be grouped together in the code generation. By grouping constraints
    -- together, we can omit unnecessary if-conditions and compute a more
    -- accurate upper bound on the number of predecessors.
    constraintGroups : [Set Int],

    -- The tables defined in the Trellis model being compiled.
    tables : Map Name TType,

    -- The names of each of the generated transition probability functions,
    -- ordered according to the declaration order of the cases they are
    -- generated from.
    transFunNames : [Name],

    -- Options passed to the compiler.
    opts : TrellisOptions,

    -- The maximum number of predecessors of any state in the model. When using
    -- the predecessor analysis, the sequence should contain a single element
    -- representing the total number of predecessors. Otherwise, when
    -- precomputing the predecessors, it contains the max number of
    -- predecessors of each case in the transition probability function.
    numPreds : [Int],

    -- Determines whether predecessors are precomputed at compile-time or if
    -- they are handled through the predecessor analysis.
    precomputedPredecessors : Bool,

    -- Components of the state type.
    stateType : [TType]
  }

  sem cudaTypeDef : CType -> Name -> CuTop
  sem cudaTypeDef ty =
  | id -> {annotations = [], top = CTTyDef {ty = ty, id = id}}

  sem cudaMacroDef : Name -> String -> CuTop
  sem cudaMacroDef id =
  | value -> {annotations = [], top = CTMacroDefine {id = id, value = value}}

  sem cudaIntMacroDef : Name -> Int -> CuTop
  sem cudaIntMacroDef id =
  | value -> cudaMacroDef id (int2string value)

  sem cudaNegInf : () -> CExpr
  sem cudaNegInf =
  | _ ->
    CEUnOp {
      op = CONeg (),
      arg = CEBinOp { op = CODiv (), lhs = CEFloat {f = 1.0}, rhs = CEFloat {f = 0.0} } }

  sem escapedTableName : Name -> Name
  sem escapedTableName =
  | id -> nameNoSym (concat "t_" (nameGetStr id))
end

lang TrellisCudaCompileTypeDefs = TrellisCudaCompileBase + TrellisTypeBitwidth
  sem generateTypeDefines : CuCompileEnv -> TModel -> [CuTop]
  sem generateTypeDefines env =
  | model ->
    let stateType = chooseMinimalIntegerType model.stateType in
    let obsType = chooseMinimalIntegerType model.outType in
    let probType =
      if env.opts.useDoublePrecisionFloats then CTyDouble ()
      else CTyFloat ()
    in
    [ cudaTypeDef stateType stateTyId
    , cudaTypeDef obsType obsTyId
    , cudaTypeDef probType probTyId ]

  sem chooseMinimalIntegerType : TType -> CType
  sem chooseMinimalIntegerType =
  | trellisTy ->
    let bitwidth = bitwidthType trellisTy in
    if lti bitwidth 8 then CTyVar {id = uint8}
    else if lti bitwidth 16 then CTyVar {id = uint16}
    else if lti bitwidth 32 then CTyVar {id = uint32}
    else if lti bitwidth 64 then CTyVar {id = uint64}
    else
      errorSingle [infoTTy trellisTy] "Bitwise representation of type requires at least 64 bits, which is not supported"
end

lang TrellisCudaConstantDefs = TrellisCudaCompileBase + TrellisTypeCardinality
  sem generateModelConstantDefines : CuCompileEnv -> TModel -> [CuTop]
  sem generateModelConstantDefines env =
  | model ->
    let numStates = cardinalityType model.stateType in
    let numObs = cardinalityType model.outType in
    let tops =
      [ cudaIntMacroDef batchSizeId env.opts.batchSize
      , cudaIntMacroDef batchOverlapId env.opts.batchOverlap
      , cudaIntMacroDef numStatesId numStates
      , cudaIntMacroDef numObsId numObs
      , cudaIntMacroDef numPredsId (foldl addi 0 env.numPreds) ]
    in
    if env.precomputedPredecessors then
      let defPrecomputePredsId = nameNoSym "PRECOMPUTE_PREDECESSORS" in
      let extraDefs =
        foldli
          (lam acc. lam i. lam c.
            let predsId = concat (nameGetStr numPredsId) (int2string i) in
            snoc acc (cudaIntMacroDef (nameNoSym predsId) c))
          [cudaMacroDef defPrecomputePredsId ""] env.numPreds
      in
      concat tops extraDefs
    else tops

  sem computeMaxPredecessors : [Set Int] -> [ConstraintRepr] -> Int
  sem computeMaxPredecessors constraintGroups =
  | c ->
    -- NOTE(larshum, 2024-05-09): As the cases (represented by the constraints)
    -- in a group are mutually exclusive in the sense that we run at most one
    -- of the cases, we compute the maximum number of predecessors among all
    -- cases in the group.
    let countMaxPredecessorsInGroup : Set Int -> Int = lam g.
      setFold (lam acc. lam i. maxi acc (countPredecessors (get c i))) 0 g
    in
    foldl addi 0 (map countMaxPredecessorsInGroup constraintGroups)
end

-- Generate the declaration of the tables as constant arrays and code for
-- copying given data for each of these tables to the GPU.
lang TrellisCudaTableDefinitions =
  TrellisCudaCompileBase + TrellisTypeCardinality

  type TableData = {
    -- The name of the table
    id : Name,

    -- The C type of the data contained in the table.
    ty : CType,

    -- The number of elements to be stored in the table.
    sz : Int,

    -- Determines whether this table should be treated as a scalar value.
    scalar : Bool
  }

  sem getModelTableData : Name -> TType -> TableData
  sem getModelTableData id =
  | ty ->
    let cty = CTyVar {id = probTyId} in
    match ty with TTable {args = !([]) & args} then
      let sz = foldl muli 1 (map cardinalityType args) in
      {id = id, ty = cty, sz = sz, scalar = false}
    else
      {id = id, ty = cty, sz = 1, scalar = true}

  sem getSyntheticTableData : Name -> TExpr -> TableData
  sem getSyntheticTableData id =
  | _ ->
    let cty = CTyVar {id = probTyId} in
    {id = id, ty = cty, sz = 1, scalar = true}

  sem getPredecessorTableData : Int -> Int -> Int -> TableData
  sem getPredecessorTableData numStates idx =
  | npreds ->
    let id = nameNoSym (concat "pred" (int2string idx)) in
    let cty = CTyVar {id = stateTyId} in
    let sz = muli npreds numStates in
    {id = id, ty = cty, sz = sz, scalar = false}

  sem generateModelTableCode : CuCompileEnv -> Map Name TExpr -> TModel -> [CuTop]
  sem generateModelTableCode env syntheticTables =
  | model ->
    -- 0. Combine the declared tables, the synthetically defined tables to
    --    simplify computations, and the predecessor tables (when used) to a
    --    uniform format, so that we can use the same code for all three
    --    categories of tables.
    let numStates = cardinalityType model.stateType in
    let numPreds =
      if env.precomputedPredecessors then env.numPreds
      else []
    in
    let tables = join [
      mapValues (mapMapWithKey getModelTableData model.tables),
      mapValues (mapMapWithKey getSyntheticTableData syntheticTables),
      mapi (getPredecessorTableData numStates) numPreds
    ] in

    -- 1. Define the size of each non-scalar table.
    match generateTableSizeDefinitions tables with (tableSizeDecls, tableSizeIdMap) in

    -- 2. Declare constant arrays, representing tables on the GPU
    let tableDecls = map (generateConstantArray tableSizeIdMap) tables in

    -- 3. Generate init function copying each value to the GPU
    let initDef = generateInitFunction tableSizeIdMap tables in

    join [tableSizeDecls, tableDecls, [initDef]]

  sem generateTableSizeDefinitions : [TableData] -> ([CuTop], Map Name Name)
  sem generateTableSizeDefinitions =
  | tables ->
    let generateTableSizeDefinition = lam acc. lam t.
      if t.scalar then acc
      else
        match acc with (tops, sizeIds) in
        let szId = nameSym (concat (nameGetStr t.id) "_SIZE") in
        let sizeIds = mapInsert t.id szId sizeIds in
        let def = CTMacroDefine {id = szId, value = int2string t.sz} in
        (snoc tops {annotations = [], top = def}, sizeIds)
    in
    foldl generateTableSizeDefinition ([], mapEmpty nameCmp) tables

  sem generateConstantArray : Map Name Name -> TableData -> CuTop
  sem generateConstantArray tableSizeIdMap =
  | table ->
    let ty =
      match mapLookup table.id tableSizeIdMap with Some sizeId then
        CTyArray {ty = table.ty, size = Some (CEInt {i = table.sz})}
      else table.ty
    in
    { annotations = [CuADevice ()]
    , top = CTDef {
        ty = ty,
        id = Some (escapedTableName table.id),
        init = None () }}

  sem generateInitFunction : Map Name Name -> [TableData] -> CuTop
  sem generateInitFunction tableSizeIdMap =
  | tables ->
    let copyTable = lam t.
      let tableArgId = nameNoSym (concat (nameGetStr t.id) "_arg") in
      let elemSize = CESizeOfType {ty = t.ty} in
      let szExpr =
        match mapLookup t.id tableSizeIdMap with Some szId then
          CEBinOp {op = COMul (), lhs = CEVar {id = szId}, rhs = elemSize}
        else elemSize
      in
      let rarg =
        if t.scalar then
          CEUnOp {op = COAddrOf (), arg = CEVar {id = tableArgId}}
        else CEVar {id = tableArgId}
      in
      let copyToSymExpr = CEApp {fun = nameNoSym "cudaMemcpyToSymbol", args = [
        CEVar {id = escapedTableName t.id}, rarg, szExpr
      ]} in
      (tableArgId, copyToSymExpr)
    in
    match unzip (map copyTable tables) with (tableArgIds, copyExprs) in
    let tableParams =
      map
        (lam t.
          match t with (argId, table) in
          let ty =
            if table.scalar then table.ty else CTyPtr {ty = table.ty}
          in
          (ty, argId))
        (zip tableArgIds tables)
    in
    { annotations = [CuAExternC ()]
    , top = CTFun {
        ret = CTyVoid (),
        id = nameNoSym "init",
        params = tableParams,
        body = map (lam e. CSExpr {expr = e}) copyExprs
    }}
end

lang TrellisCudaCompileExpr = TrellisCudaCompileBase + TrellisModelTypePrettyPrint
  sem cudaCompileTrellisExpr : Set Name -> TExpr -> CExpr
  sem cudaCompileTrellisExpr bound =
  | EBool {b = b} -> CEInt {i = if b then 1 else 0}
  | EVar {id = id, info = info} ->
    if setMem id bound then CEVar {id = id}
    else errorSingle [info] "Found unbound variable in CUDA code generation"
  | EInt {i = i} -> CEInt {i = i}
  | EProb {p = p} -> CEFloat {f = log p}
  | ESlice {info = info} ->
    errorSingle [info] "Internal error: Found slice in CUDA code generation"
  | ETableAccess {table = tableId, args = []} ->
    CEVar {id = escapedTableName tableId}
  | ETableAccess {table = tableId, args = [arg]} ->
    CEBinOp {
      op = COSubScript (), lhs = CEVar {id = escapedTableName tableId},
      rhs = cudaCompileTrellisExpr bound arg }
  | ETableAccess {args = [_, _] ++ _, info = info} ->
    errorSingle [info] "Internal error: Expected table access to have zero or one arguments after transformations"
  | EUnOp {op = ONot _, target = target} ->
    let cond = cudaCompileTrellisExpr bound target in
    CETernary {cond = cond, thn = CEInt {i = 0}, els = CEInt {i = 1}}
  | EBinOp ({op = OAdd _ | OSub _ | OMul _ | ODiv _ | OMod _} & t) ->
    compileArithmeticOperation bound t
  | EBinOp t ->
    bop (compileOp t.op)
      (cudaCompileTrellisExpr bound t.lhs)
      (cudaCompileTrellisExpr bound t.rhs)

  type BinOpRecord = {op : BOp, lhs : TExpr, rhs : TExpr, ty : TType, info : Info}

  sem compileArithmeticOperation : Set Name -> BinOpRecord -> CExpr
  sem compileArithmeticOperation bound =
  | {op = op, lhs = lhs, rhs = rhs, ty = ty, info = info} ->
    let lhs = cudaCompileTrellisExpr bound lhs in
    let rhs = cudaCompileTrellisExpr bound rhs in
    match ty with TInt _ then
      compileIntegerOperation lhs rhs op
    else match ty with TProb _ then
      compileProbabilityOperation info lhs rhs op
    else
      errorSingle [info]
        (concat "Invalid type of arithmetic operation: " (pprintTrellisType ty))

  sem compileIntegerOperation : CExpr -> CExpr -> BOp -> CExpr
  sem compileIntegerOperation lhs rhs =
  | OAdd _ -> bop (COAdd ()) lhs rhs
  | OSub _ -> bop (COSub ()) lhs rhs
  | OMul _ -> bop (COMul ()) lhs rhs
  | ODiv _ -> bop (CODiv ()) lhs rhs
  | OMod _ -> bop (COMod ()) lhs rhs

  sem compileProbabilityOperation : Info -> CExpr -> CExpr -> BOp -> CExpr
  sem compileProbabilityOperation info lhs rhs =
  | op & (OAdd _ | OSub _) ->
    let cOperator =
      match op with OAdd _ then COAdd () else COSub ()
    in
    -- NOTE(larshum, 2024-05-08): Addition and subtraction on probabilities,
    -- which are represented in a logarithmic scale, requires exponentiating
    -- both arguments and computing the logarithm of the result.
    let expCExpr = lam e. CEApp {fun = nameNoSym "exp", args = [e]} in
    let logCExpr = lam e. CEApp {fun = nameNoSym "log", args = [e]} in
    logCExpr (bop cOperator (expCExpr lhs) (expCExpr rhs))
  | op & (OMul _ | ODiv _) ->
    let cOperator =
      match op with OMul _ then COAdd () else COSub ()
    in
    bop cOperator lhs rhs
  | OMod _ ->
    errorSingle [info] "Modulo operation not supported on probabilities"

  sem compileOp : BOp -> CBinOp
  sem compileOp =
  | OEq _ -> COEq ()
  | ONeq _ -> CONeq ()
  | OLt _ -> COLt ()
  | OGt _ -> COGt ()
  | OLeq _ -> COLe ()
  | OGeq _ -> COGe ()
  | OAnd _ -> COAnd ()
  | OOr _ -> COOr ()
end

lang TrellisCudaCompileSet = TrellisCudaCompileExpr
  sem cudaCompileTrellisSet : TSet -> CExpr
  sem cudaCompileTrellisSet =
  | SAll _ -> CEInt {i = 1}
  | STransitionBuilder {x = x, y = y, conds = conds} ->
    let joinAnd = lam l. lam r. CEBinOp { op = COAnd (), lhs = l, rhs = r} in
    let bound = setOfSeq nameCmp [x, y] in
    let c = map (cudaCompileTrellisExpr bound) conds in
    match c with [h] ++ t then
      foldl joinAnd h t
    else CEInt {i = 1}
end

lang TrellisCudaProbabilityFunction =
  TrellisCudaCompileExpr + TrellisCudaCompileSet

  sem generateProbabilityFunctions : CuCompileEnv -> InitialProbDef
                                  -> OutputProbDef -> TransitionProbDef
                                  -> (CuCompileEnv, [CuTop])
  sem generateProbabilityFunctions env init out =
  | trans ->
    let stateTy = CTyVar {id = stateTyId} in
    let obsTy = CTyVar {id = obsTyId} in
    let initParams = [(stateTy, init.x)] in
    let initFun = generateCaseProbabilityFunction initParams initProbFunId init.body in
    let outParams = [(stateTy, out.x), (obsTy, out.o)] in
    let outFun = generateCaseProbabilityFunction outParams outProbFunId out.body in

    -- NOTE(larshum, 2024-04-26): We generate a separate transition probability
    -- function containing the body of each case so we can refer to them
    -- direcly based on our predecessor analysis.
    let transParams = [(stateTy, trans.x), (stateTy, trans.y)] in
    match unzip (map (generateTransitionCaseProbabilityFunction transParams) trans.cases)
    with (funNames, transFuns) in
    let env = {env with transFunNames = funNames} in
    (env, concat [initFun, outFun] transFuns)

  sem generateTransitionCaseProbabilityFunction : [(CType, Name)] -> TCase -> (Name, CuTop)
  sem generateTransitionCaseProbabilityFunction params =
  | {cond = _, body = body} ->
    let id = nameSym "transition_prob" in
    (id, generateCaseProbabilityFunction params id body)

  sem generateCaseProbabilityFunction : [(CType, Name)] -> Name -> TExpr -> CuTop
  sem generateCaseProbabilityFunction params id =
  | body ->
    let singleCase = {cond = SAll {info = cinfo}, body = body} in
    generateProbabilityFunction id params [singleCase]

  sem generateProbabilityFunction : Name -> [(CType, Name)] -> [TCase] -> CuTop
  sem generateProbabilityFunction id params =
  | cases ->
    let bound = setOfSeq nameCmp (map (lam p. p.1) params) in
    let body =
      match cases with [{cond = SAll _, body = body}] then
        CSRet {val = Some (cudaCompileTrellisExpr bound body)}
      else
        let baseStmt = CSRet {val = Some (cudaNegInf ())} in
        foldl (generateProbabilityFunctionBody bound) baseStmt cases
    in
    let top = CTFun {
      ret = CTyVar {id = probTyId}, id = id, params = params, body = [body]
    } in
    {annotations = [CuADevice ()], top = top}

  sem generateProbabilityFunctionBody : Set Name -> CStmt -> TCase -> CStmt
  sem generateProbabilityFunctionBody bound acc =
  | {cond = cond, body = body} ->
    CSIf {
      cond = cudaCompileTrellisSet cond,
      thn = [CSRet {val = Some (cudaCompileTrellisExpr bound body)}],
      els = [acc]
    }
end

lang TrellisCudaCompileTransitionCase =
  TrellisCudaCompileExpr + TrellisEncodeExpr + TrellisTypeCardinality +
  TrellisModelMergeSubsequentOperations

  syn CValue =
  -- A fixed component value, constrained by an equality constraint on an
  -- integer literal.
  | CFixed Int

  -- A fixed component value, constrained by an equality constraint on a
  -- component of the to-state, where the integer argument denotes the index of
  -- this component.
  | CFixedY Int

  -- A fixed component value, constrained by a relation to a component of the
  -- to-state. Contains an expression referring to a component of the (encoded)
  -- to-state and a literal offset.
  | CFixedYPlus (TExpr, Int)

  -- A flexible component value, constrained by inequality constraint
  -- specifying particular values the component cannot take.
  | CFlex [Int]

  -- Representation of the values to be generated for a state component.
  type ComponentValue = {
    -- The identifier to which the value of the state component is bound.
    id : Name,

    -- The upper bound value of this component, as determined by its type.
    ub : Int,

    -- A representation of the value of a state component, which is either
    -- fixed to a particular value if it has any equality constraints or
    -- flexible and restricted by zero or more inequality constraints.
    value : CValue
  }

  -- Abstract representation of a case in the transition probability function.
  type TransitionCase = {
    -- A conditional expression determining whether this case is applicable for
    -- a given to-state. This is computed based on the constraints on the
    -- components of the to-state.
    targetStateCond : TExpr,

    -- The encoded representation of the predecessor as an integer.
    predecessorExpr : TExpr,

    -- The representation of each component of the from-state, determining the
    -- identifier to which a component is bound and the values it may take.
    predecessorComponents : [ComponentValue],

    -- The name of the transition probability function computing the actual
    -- value to be produced by this case.
    probFunName : Name,

    -- The abstract constraints which this case represents.
    constraints : ConstraintRepr
  }

  -- Converts the representation of a constraint on a case of the transition
  -- probability function to an abstract representation from which the goal
  -- CUDA code can easily be generated. We use this abstract representation
  -- instead of directly outputting the CUDA code so that we can perform
  -- optimization decisions later, independently of this step.
  sem toTransitionCase : CuCompileEnv -> Name -> ConstraintRepr -> TransitionCase
  sem toTransitionCase env id =
  | repr ->
    let combineTransitionConds = lam exprs.
      joinBoolAnd (map encodeStateOperationsExpr (foldl mergeSubsequentOperations [] exprs))
    in
    let combinePredecessorConds = lam exprs.
      joinAdd 1 (map encodeStateOperationsExpr (foldl mergeSubsequentOperations [] exprs))
    in
    match predecessorCondition env repr with (exprs, components) in
    { targetStateCond = combineTransitionConds (transitionCondition env repr)
    , predecessorExpr = combinePredecessorConds exprs
    , predecessorComponents = components
    , probFunName = id
    , constraints = repr }

  -- Combines a sequence of boolean expressions to one expression performing
  -- boolean AND of the components. If the sequence is empty, we return a true
  -- expression.
  sem joinBoolAnd : [TExpr] -> TExpr
  sem joinBoolAnd =
  | [] -> EBool {b = true, ty = TBool {info = cinfo}, info = cinfo}
  | [h] ++ t ->
    let boolAnd = lam acc. lam e.
      EBinOp {
        op = OAnd (), lhs = acc, rhs = e,
        ty = TBool {info = cinfo}, info = cinfo }
    in
    foldl boolAnd h t

  -- Combines a sequence of integer expressions by adding them together.
  sem joinAdd : Int -> [TExpr] -> TExpr
  sem joinAdd n =
  | [] -> error "Internal error: Empty sequence of components"
  | rest ++ [last] ->
    let ty = TInt {bounds = None (), info = cinfo} in
    let expr =
      if eqi n 1 then last
      else
        EBinOp {
          op = OMul (), lhs = last, rhs = EInt {i = n, ty = ty, info = cinfo},
          ty = ty, info = cinfo }
    in
    if null rest then expr
    else
      let n = muli n (cardinalityType (tyTExpr last)) in
      EBinOp {
        op = OAdd (), lhs = joinAdd n rest, rhs = expr,
        ty = ty, info = cinfo }

  -- Given the representation of a set constraint, computes a condition
  -- determining whether a given to-state may have predecessors from this case.
  sem transitionCondition : CuCompileEnv -> ConstraintRepr -> [TExpr]
  sem transitionCondition env =
  | {y = y} ->
    let f = lam acc. lam idx. lam constraints.
      let componentType = get env.stateType idx in
      let componentExpr = lam id. ESlice {
        target = EVar {
          id = id, ty = TTuple {tys = env.stateType, info = cinfo},
          info = cinfo },
        lo = idx, hi = idx, ty = componentType, info = cinfo
      } in
      foldl (addPredConstraint env.stateType stateId componentExpr)
        acc (setToSeq constraints)
    in
    mapFoldWithKey f [] y

  sem addPredConstraint : [TType] -> Name -> (Name -> TExpr) -> [TExpr]
                       -> PredConstraint -> [TExpr]
  sem addPredConstraint stateType componentId componentExpr acc =
  | c ->
    let cexpr = predConstraintToExpr stateType componentId componentExpr c in
    snoc acc cexpr

  sem predConstraintToExpr : [TType] -> Name -> (Name -> TExpr) -> PredConstraint -> TExpr
  sem predConstraintToExpr stateType componentId componentExpr =
  | EqNum (n, _) ->
    let intTy = TInt {bounds = None (), info = cinfo} in
    let arg = EInt { i = n, ty = intTy, info = cinfo } in
    EBinOp { op = OEq (), lhs = componentExpr componentId, rhs = arg,
             ty = TBool {info = cinfo}, info = cinfo }
  | NeqNum (n, _) ->
    let intTy = TInt {bounds = None (), info = cinfo} in
    let arg = EInt { i = n, ty = intTy, info = cinfo } in
    EBinOp { op = ONeq (), lhs = componentExpr componentId, rhs = arg,
             ty = TBool {info = cinfo}, info = cinfo }
  | EqYPlusNum (yidx, n, _) ->
    let intTy = TInt {bounds = None (), info = cinfo} in
    let arg = EBinOp {
      op = OAdd (),
      lhs = componentExpr stateId,
      rhs = EInt { i = n, ty = intTy, info = cinfo },
      ty = intTy, info = cinfo
    } in
    EBinOp { op = OEq (), lhs = componentExpr componentId, rhs = arg,
             ty = TBool {info = cinfo}, info = cinfo }

  -- Given the representation of a set constraint, computes expressions
  -- representing each component of a predecessor. Also, for each component of
  -- the predecessor, computes the values for which it is valid.
  sem predecessorCondition : CuCompileEnv -> ConstraintRepr -> ([TExpr], [ComponentValue])
  sem predecessorCondition env =
  | {state = state, x = x, y = y} & c ->
    let produceComponentRepr = lam i. lam componentSize.
      let value = computeComponentValue env c i in
      { id = nameSym "x", ub = componentSize, value = value }
    in
    let f = lam c.
      let ty = TInt {bounds = Some (0, subi c.ub 1), info = cinfo} in
      match c.value with CFixed n then
        EInt {i = n, ty = ty, info = cinfo}
      else match c.value with CFixedY yidx then
        let t = EVar {
          id = stateId, ty = TTuple {tys = env.stateType, info = cinfo},
          info = cinfo
        } in
        ESlice {
          target = t, lo = yidx, hi = yidx, ty = get env.stateType yidx,
          info = cinfo }
      else match c.value with CFixedYPlus (yexpr, n) then
        EBinOp {
          op = OAdd (),
          lhs = yexpr,
          rhs = EInt {i = n, ty = ty, info = cinfo},
          ty = ty, info = cinfo }
      else
        EVar {id = c.id, ty = ty, info = cinfo}
    in
    let componentValues = mapi produceComponentRepr state in
    let componentExprs = map f componentValues in
    (componentExprs, componentValues)

  -- Computes a representation of the value of a component based on the
  -- constraints imposed on it.
  sem computeComponentValue : CuCompileEnv -> ConstraintRepr -> Int -> CValue
  sem computeComponentValue env constraint =
  | idx ->
    let lookupEqLitConstraint =
      findMap
        (lam c. match c with EqNum (n, _) then Some n else None ())
    in
    let lookupEqYConstraint =
      findMap
        (lam c.
          match c with EqYPlusNum (yidx, n, _) then Some (yidx, n)
          else None ())
    in
    let fixedYConstraint = lam yidx. lam n.
      if eqi n 0 then CFixedY yidx else
      let sliceExpr = ESlice {
        target = EVar {
          id = stateId, ty = TTuple {tys = env.stateType, info = cinfo},
          info = cinfo },
        lo = yidx, hi = yidx, ty = get env.stateType yidx, info = cinfo
      } in
      CFixedYPlus (sliceExpr, n)
    in
    let collectNeqConstraints =
      mapOption (lam c. match c with NeqNum (n, _) then Some n else None ())
    in
    match mapLookup idx constraint.x with Some constraintSet then
      let constraints = setToSeq constraintSet in
      match lookupEqLitConstraint constraints with Some n then
        -- NOTE(larshum, 2024-05-09): If the to-state has a literal constraint,
        -- so that it is also fixed, then we express our constraint in terms of
        -- that state to enable later optimizations of the resulting predecessor
        -- expression.
        match
          optionBind
            (mapLookup idx constraint.y)
            (lam c. lookupEqLitConstraint (setToSeq c))
        with Some yn then
          let diff = subi n yn in
          fixedYConstraint idx diff
        else
          CFixed n
      else match lookupEqYConstraint constraints with Some (yidx, n) then
        fixedYConstraint yidx n
      else CFlex (collectNeqConstraints constraints)
    else CFlex []
end

lang TrellisCudaHMM = TrellisCudaCompileExpr + TrellisCudaCompileTransitionCase

  sem generatePredecessorFunctions : CuCompileEnv -> [CuTop]
  sem generatePredecessorFunctions =
  | env ->
    let groups =
      if env.precomputedPredecessors then
        -- If we are precomputing the predecessors, we still store the
        -- identifier of the transition probability function of each case. The
        -- other parts are unused, so we give them default values.
        let i = NoInfo () in
        let emptyRepr = {
          state = [0], x = mapEmpty subi, y = mapEmpty subi, info = i
        } in
        let emptyExpr =
          EInt {i = 0, ty = TInt {bounds = None (), info = i}, info = i}
        in
        map
          (lam id.
            [{ targetStateCond = emptyExpr
             , predecessorExpr = emptyExpr
             , predecessorComponents = []
             , probFunName = id
             , constraints = emptyRepr }])
          env.transFunNames
      else
        -- Convert the constraint representation to another intermediate
        -- representation which abstractly represents how we need to compute the
        -- value of each component of a predecessor.
        let transitionCases =
          mapi
            (lam i. lam c.
              let id = get env.transFunNames i in
              toTransitionCase env id c)
            env.constraints
        in

        -- Group together transition cases based on the result of our earlier
        -- analysis.
        map (lam g. map (get transitionCases) (setToSeq g)) env.constraintGroups
    in

    -- Generate CUDA code for each algorithm, considering each group of cases
    -- one by one.
    [ generateForwardProbPredecessors env groups
    , generateViterbiMaxPredecessors env groups ]

  -- Generates a function used to compute the probability of each predecessor
  -- of a given state. This function is used by the Forward algorithm in the
  -- pre-defined template code.
  sem generateForwardProbPredecessors : CuCompileEnv -> [[TransitionCase]] -> CuTop
  sem generateForwardProbPredecessors env =
  | caseGroups ->
    let alphaPrevId = nameSym "alpha_prev" in
    let instanceId = nameSym "instance" in
    let probsId = nameSym "probs" in
    let params = [
      -- const prob_t *alpha_prev;
      (CTyConst {ty = CTyPtr {ty = CTyVar {id = probTyId}}}, alphaPrevId),
      -- int instance;
      (CTyInt (), instanceId),
      -- state_t state;
      (CTyVar {id = stateTyId}, stateId),
      -- prob_t probs;
      (CTyPtr {ty = CTyVar {id = probTyId}}, probsId)
    ] in
    let pidx = nameSym "pidx" in
    let forwardCode = CSComp {
      stmts = [
        -- probs[pidx] = p + alpha_prev[instance * NUM_STATES + pred];
        CSExpr { expr =
          bop (COAssign ())
            (bop (COSubScript ()) (var probsId) (var pidx))
            (bop (COAdd ()) (var probId)
              (bop (COSubScript ()) (var alphaPrevId)
                (bop (COAdd ())
                  (bop (COMul ()) (var instanceId) (var numStatesId))
                  (var predId)))) },
        -- pidx = pidx + 1
        CSExpr { expr =
          bop (COAssign ())
            (var pidx)
            (bop (COAdd ()) (var pidx) (CEInt {i = 1})) }
      ]
    } in
    let stmts =
      if env.precomputedPredecessors then
        mapi (lookupPredecessorsCase env forwardCode) caseGroups
      else
        map (generatePredecessorsCases env forwardCode) caseGroups
    in
    let top = CTFun {
      ret = CTyInt (), id = forwProbPredsFunId, params = params,
      body = join [[
        -- int pidx = 0;
        CSDef {
          ty = CTyInt (), id = Some pidx,
          init = Some (CIExpr {expr = CEInt {i = 0}}) },
        -- state_t pred;
        CSDef {
          ty = CTyVar {id = stateTyId}, id = Some predId, init = None () },
        -- prob_t p;
        CSDef {
          ty = CTyVar {id = probTyId}, id = Some probId, init = None () }],
        stmts,
        -- return pidx;
        [CSRet {val = Some (CEVar {id = pidx})}]
      ]
    } in
    { annotations = [CuADevice ()], top = top }

  sem generateViterbiMaxPredecessors : CuCompileEnv -> [[TransitionCase]] -> CuTop
  sem generateViterbiMaxPredecessors env =
  | caseGroups ->
    let chiPrevId = nameSym "chi_prev" in
    let instanceId = nameSym "instance" in
    let maxStateId = nameSym "maxs" in
    let maxProbId = nameSym "maxp" in
    let params = [
      -- const prob_t *chi_prev
      (CTyConst {ty = CTyPtr {ty = CTyVar {id = probTyId}}}, chiPrevId),
      -- int instance;
      (CTyInt (), instanceId),
      -- state_t state;
      (CTyVar {id = stateTyId}, stateId),
      -- state_t *maxs;
      (CTyPtr {ty = CTyVar {id = stateTyId}}, maxStateId),
      -- prob_t *maxp;
      (CTyPtr {ty = CTyVar {id = probTyId}}, maxProbId)
    ] in
    let viterbiCode = CSComp {
      stmts = [
        -- p = p + chi_prev[instance * NUM_STATES + pred];
        CSExpr {expr =
          bop (COAssign ()) (var probId)
            (bop (COAdd ()) (var probId)
              (bop (COSubScript ()) (var chiPrevId)
                (bop (COAdd ())
                  (bop (COMul ()) (var instanceId) (var numStatesId))
                  (var predId)))) },
        CSIf {
          -- if (p > *maxp) {
          cond = bop (COGt ()) (var probId) (uop (CODeref ()) (var maxProbId)),
          thn = [
            -- *maxs = pred;
            CSExpr {expr =
              bop (COAssign ()) (uop (CODeref ()) (var maxStateId)) (var predId) },
            -- *maxp = p;
            CSExpr {expr =
              bop (COAssign ()) (uop (CODeref ()) (var maxProbId)) (var probId) }
          ],
          els = [] }
      ]
    } in
    let stmts =
      if env.precomputedPredecessors then
        mapi (lookupPredecessorsCase env viterbiCode) caseGroups
      else
        map (generatePredecessorsCases env viterbiCode) caseGroups
    in
    let top = CTFun {
      ret = CTyVoid (), id = viterbiMaxPredsFunId, params = params,
      body = concat [
        -- state_t pred;
        CSDef {
          ty = CTyVar {id = stateTyId}, id = Some predId, init = None () },
        -- prob_t p;
        CSDef {
          ty = CTyVar {id = probTyId}, id = Some probId, init = None () }
      ] stmts
    } in
    { annotations = [CuADevice ()], top = top }

  -- Generates a statement looking up the predecessors of the provided case in
  -- a table provided at runtime by the Python wrapper.
  sem lookupPredecessorsCase : CuCompileEnv -> CStmt -> Int -> [TransitionCase] -> CStmt
  sem lookupPredecessorsCase env tailStmt idx =
  | [{probFunName = probFunId}] ->
    let stateTy = CTyVar {id = stateTyId} in
    let tablePtrId = escapedTableName (nameNoSym (concat "pred" (int2string idx))) in
    let id = nameSym "i" in
    -- NOTE(larshum, 2024-05-29): We represent a non-existent predecessor
    -- with a state value beyond the upper bound (NUM_STATES or greater) in
    -- the predecessor lookup tables.
    let innerStmts = CSComp {stmts = [
      -- pred = <table>[i * NUM_STATES + state];
      CSExpr {expr =
        bop (COAssign ()) (var predId)
          (bop (COSubScript ()) (var tablePtrId)
            (bop (COAdd ())
              (bop (COMul ()) (var id) (var numStatesId))
              (var stateId)))},
      -- if (pred < NUM_STATES)
      CSIf {
        cond = bop (COLt ()) (var predId) (var numStatesId),
        thn = [
          -- p = <transp_fun>(pred, state);
          CSExpr {expr =
            bop (COAssign ()) (var probId)
              (CEApp {
                fun = probFunId,
                args = [var predId, var stateId]})},
          tailStmt
        ],
        els = [] }
    ]} in
    let upperBoundId = concat (nameGetStr numPredsId) (int2string idx) in
    CSComp {stmts = [
      CSDef {
        ty = CTyVar {id = stateTyId}, id = Some id,
        init = Some (CIExpr {expr = CEInt {i = 0}}) },
      CSWhile {
        cond = bop (COLt ()) (var id) (var (nameNoSym upperBoundId)),
        body = [
          innerStmts,
          CSExpr {expr =
            bop (COAssign ()) (var id) (bop (COAdd ()) (var id) (CEInt {i = 1})) }
        ]}
    ]}
  | _ -> error "Invalid argument of lookupPredecessorsCase"

  -- Generates a statement computing the predecessors of all provided cases. If
  -- only one case is provided, we insert the tail statement inside the code
  -- generated for that particular state, as the statement may be used multiple
  -- times within a loop. Otherwise, if we have multiple cases, we insert this
  -- tail statement after all cases have ran. This should only happen when the
  -- cases are independent of each other and do not include loops.
  sem generatePredecessorsCases : CuCompileEnv -> CStmt
                               -> [TransitionCase] -> CStmt
  sem generatePredecessorsCases env tailStmt =
  | [c] -> generatePredecessorCase env tailStmt c
  | cases ->
    let stmts =
      map
        (lam c.
          let tailStmt =
            if gti (countPredecessors c.constraints) 1 then tailStmt
            else CSNop ()
          in
          generatePredecessorCase env tailStmt c)
      cases
    in
    CSComp { stmts = snoc stmts tailStmt }

  sem generatePredecessorCase : CuCompileEnv -> CStmt -> TransitionCase -> CStmt
  sem generatePredecessorCase env tailStmt =
  | { targetStateCond = targetStateCond, predecessorExpr = predecessorExpr
     , predecessorComponents = comps, probFunName = probFunId } ->
    let bound =
      setOfSeq nameCmp (concat [stateId, predId] (map (lam c. c.id) comps))
    in
    let innerStmts = CSComp {stmts = [
      -- pred = <pred expr>;
      CSExpr { expr =
        bop (COAssign ()) (var predId)
          (cudaCompileTrellisExpr bound predecessorExpr)},
      -- p = transp(pred, state);
      CSExpr { expr =
        bop (COAssign ()) (var probId)
          (CEApp {
            fun = probFunId,
            args = [var predId, var stateId]})},
      tailStmt
    ]} in
    let stmt = foldl (generatePredecessorComponent env) innerStmts comps in
    match targetStateCond with EBool {b = true} then stmt
    else
      CSIf {
        cond = cudaCompileTrellisExpr bound targetStateCond,
        thn = [stmt], els = [] }

  -- Generates code for initializing a particular component, and ensuring that
  -- its value is within its constrained bounds. If a component is only
  -- constrained via inequalities, we generate values in a loop and skip those
  -- that are marked as disallowed.
  sem generatePredecessorComponent : CuCompileEnv -> CStmt -> ComponentValue -> CStmt
  sem generatePredecessorComponent env acc =
  | {value = CFixed _ | CFixedY _ | CFixedYPlus _} ->
    -- NOTE(larshum, 2024-05-07): For this case, we inline the definition to
    -- allow optimizations, so we do not introduce any new variables here.
    acc
  | {id = id, ub = ub, value = CFlex prohibited} ->
    let for = lam id. lam init. lam max. lam body.
      CSComp {stmts = [
        CSDef {
          ty = CTyVar {id = stateTyId}, id = Some id,
          init = Some (CIExpr {expr = CEInt {i = init}}) },
        CSWhile {
          cond = bop (COLt ()) (var id) (CEInt {i = max}),
          body = [
            body,
            CSExpr {expr =
              bop (COAssign ()) (var id) (bop (COAdd ()) (var id) (CEInt {i = 1})) }
          ]}
      ]}
    in
    let body =
      match prohibited with [h] ++ t then
        let neqCheck = lam n. bop (CONeq ()) (var id) (CEInt {i = n}) in
        let combineNeqChecks = lam acc. lam n.
          bop (COAnd ()) acc (neqCheck n)
        in
        let condition = foldl combineNeqChecks (neqCheck h) t in
        CSIf { cond = condition, thn = [acc], els = [] }
      else acc
    in
    for id 0 ub body
end

lang TrellisGroupConstraints = TrellisModelPredecessorAnalysis
  sem groupMutuallyExclusiveConstraints : CuCompileEnv -> CuCompileEnv
  sem groupMutuallyExclusiveConstraints =
  | env ->
    let n = length env.constraints in

    if env.opts.skipDependencyAnalysis then
      {env with constraintGroups = mapi (lam i. lam. setInsert i (setEmpty subi)) env.constraints}
    else

    -- Construct an undirected graph where each vertex represents a constraint
    -- representation (a case in the transition probability function). We add
    -- an edge between a pair of cases if they have independent to-states
    -- (meaning at most one of them may run simultaneously for a given
    -- to-state).
    let g =
      foldli
        (lam g. lam i. lam. digraphAddVertexCheck i g true)
        (graphEmpty subi (lam. lam. true)) env.constraints
    in
    let g =
      foldli
        (lam g. lam i. lam c1.
          foldli
            (lam g. lam j. lam c2.
              if gti i j then
                addEdgeIfDisjointTargetStateConstraints g (i, c1) (j, c2)
              else
                g)
            g env.constraints)
        g env.constraints
    in

    -- We use the Bron-Kerbosch algorithm to find all maximal cliques of the
    -- graph. Each clique represents a set of constraints that are all disjoint
    -- from each other. We sort these by length so that we start by considering
    -- the larger cliques (more valuable).
    -- NOTE(larshum, 2024-05-09): Computing the maximal cliques of a graph is
    -- an NP-complete problem, so this part scales very poorly with the number
    -- of vertices. However, as the number of vertices are the number of cases
    -- in the transition probability function, this should be acceptable for
    -- most typical Trellis programs.
    let cliques = bronKerbosch g in
    let cliques = sort (lam l. lam r. subi (setSize r) (setSize l)) cliques in

    -- Go through all cliques and try to add the constraints of each clique as
    -- a constraint group. After going through all cliques, add the remaining
    -- constraints one-by-one as singleton groups.
    let cg = addDisjointCliqueGroups env.constraints cliques in
    {env with constraintGroups = addDisjointCliqueGroups env.constraints cliques}

  -- For an SCC with two or more constraints, we verify that the combination of
  -- all cases cover all possible to-states, such that we must always take
  -- exactly one of the cases. If they do, we group them together, and
  -- otherwise we split them up individually.
  sem addDisjointCliqueGroups : [ConstraintRepr] -> [Set Int] -> [Set Int]
  sem addDisjointCliqueGroups constraints =
  | cliques ->
    let addSingleConstraintGroup = lam cg. lam v.
      cons (setOfSeq subi [v]) cg
    in
    let vertices = setOfSeq subi (create (length constraints) (lam i. i)) in

    -- Try to add all the vertices in each clique to a separate group of
    -- constraints, which we can handle in a more efficient way than if all
    -- constraints are considered individually. The result is the remaining
    -- vertices, that were not added to any group, and the constraint groups
    -- that were successfully formed from cliques.
    match foldl (tryAddCliqueGroup constraints) (vertices, []) cliques
    with (remainingVertices, constraintGroups) in

    -- Add all remaining vertices after attempting to insert groups of
    -- constraints that form a clique in the graph.
    setFold addSingleConstraintGroup constraintGroups remainingVertices

  sem tryAddCliqueGroup : [ConstraintRepr] -> (Set Int, [Set Int]) -> Set Int
                       -> (Set Int, [Set Int])
  sem tryAddCliqueGroup constraints acc =
  | cliqueSet ->
    match acc with (remainingVertices, constraintGroups) in

    -- If any node in the clique has been added to another group, we do not
    -- consider it again.
    let clique = setToSeq cliqueSet in
    if forAll (lam x. setMem x remainingVertices) clique then
      let c = map (get constraints) clique in
      -- NOTE(larshum, 2024-05-09): The current implementation only supports
      -- merging cases that produce exactly one predecessor, as other cases
      -- would require some kind of unrolling.
      if any (lam x. gti (countPredecessors x) 1) c then acc else
      switch result.consume (checkCoversAllTargetStates c)
      case (_, Right true) then
        ( setSubtract remainingVertices cliqueSet
        , cons cliqueSet constraintGroups )
      case (_, Right false) then
        acc
      case (_, Left errs) then
        let errStr = printConstraintErrorMessage true (z3Error errs) in
        let msg = join [
          "Grouping of constraints failed:\n", errStr, "\n"
        ] in
        printError msg;
        exit 1
      end
    else acc

  sem addEdgeIfDisjointTargetStateConstraints
    : Graph Int () -> (Int, ConstraintRepr) -> (Int, ConstraintRepr) -> Graph Int ()
  sem addEdgeIfDisjointTargetStateConstraints g x =
  | (j, c2) ->
    match x with (i, c1) in
    switch result.consume (disjointTargetStateConstraints c1 c2)
    case (_, Right true) then
      graphAddEdge i j () g
    case (_, Right false) then g
    case (_, Left errs) then
      let errStr = printConstraintErrorMessage true (z3Error errs) in
      let msg = join [
        "Grouping of constraints failed:\n", errStr, "\n"
      ] in
      printError msg;
      exit 1
    end
end

-- Computes the predecessors of each state of a given model.
lang TrellisCudaComputePredecessors =
  TrellisCudaCompileTypeDefs + TrellisCudaProbabilityFunction +
  TrellisCudaPrettyPrint

  sem computePredecessors : CuCompileEnv -> TModel -> [Int]
  sem computePredecessors env =
  | model ->
    -- Read the template implementation for the predecessor computation.
    let skeletonCode = readFile (concat trellisSrcLoc "skeleton/preds.cu") in

    -- Generate code for the header, where we define a customized transition
    -- probability function and the minimal amount of declarations needed for
    -- computing the maximum number of predecessors.
    let header = generatePredecessorHeaderCode env model in

    -- Pretty-print the header and combine it with the pre-defined skeleton
    -- code.
    let program = concat (printCudaProgram header) skeletonCode in

    -- Construct the required program files and run it to compute the
    -- predecessors, store them in a file, and finally, return the maximum
    -- number of predecessors.
    let tempDir = buildPredecessorProgram program in
    runPredecessorProgram env.opts tempDir model

  sem generatePredecessorHeaderCode : CuCompileEnv -> TModel -> CuProgram
  sem generatePredecessorHeaderCode env =
  | model ->
    -- NOTE(larshum, 2024-05-29): Inform users early about a limitation in the
    -- current implementation of the predecessor computation.
    (if geqi (cardinalityType model.stateType) (slli 1 32) then
      error (join [
        "Trellis does not yet support precomputing predecessors of models ",
        "with 2^64 states or more."
      ])
    else ());

    -- Generate the minimal amount of declarations needed for the predecessor
    -- computation.
    let numStatesDef =
      let v = int2string (cardinalityType model.stateType) in
      {annotations = [], top = CTMacroDefine {id = numStatesId, value = v}}
    in
    let tyDefs = generateTypeDefines env model in

    -- Generate a version of the transition probability function where the body
    -- of each case returns zero. We use the zero to determine whether a case
    -- in the transition probability function was taken or if it went through
    -- to the default value.
    let zModel = modelWithZeroTransitionBodies model in
    match generateTransProbFunCases zModel with (funNames, transFuns) in
    let isPredecessorFun = generateIsPredecessorFun funNames in

    { includes = ["<cstdint>", "<cstdio>"]
    , tops = join [tyDefs, [numStatesDef], transFuns, [isPredecessorFun]] }

  sem modelWithZeroTransitionBodies : TModel -> TModel
  sem modelWithZeroTransitionBodies =
  | model & {transition = t} ->
    let setCaseBodyToZero : TCase -> TCase = lam c.
      -- NOTE(larshum, 2024-05-12): Probabilities are represented in
      -- logarithmic scale. We use 1.0 here as it becomes zero in logscale.
      let i = infoTExpr c.body in
      {c with body = EProb {p = 1.0, ty = TProb {info = i}, info = i}}
    in
    {model with transition = {t with cases = map setCaseBodyToZero t.cases}}

  -- Generate a custom transition probability function for each case, where the
  -- return value is zero if the given source state is a predecessor of the
  -- given target state, and one otherwise (floating-point values).
  sem generateTransProbFunCases : TModel -> ([Name], [CuTop])
  sem generateTransProbFunCases =
  | model & {transition = t} ->
    let stateTy = CTyVar {id = uint32} in
    let transParams = [(stateTy, t.x), (stateTy, t.y)] in
    let bound = setOfSeq nameCmp [t.x, t.y] in
    let generateFunctionCase = lam c.
      let id = nameSym "transp_fun" in
      let baseStmt = CSRet {val = Some (CEFloat {f = 1.0})} in
      let body = generateProbabilityFunctionBody bound baseStmt c in
      let top = CTFun {
        ret = CTyVar {id = probTyId}, id = id, params = transParams, body = [body]
      } in
      (id, {annotations = [CuADevice ()], top = top})
    in
    unzip (map generateFunctionCase t.cases)

  sem generateIsPredecessorFun : [Name] -> CuTop
  sem generateIsPredecessorFun =
  | transpNames ->
    let srcId = nameSym "src" in
    let dstId = nameSym "dst" in
    let iId = nameSym "i" in
    let transpApp = lam id.
      CEApp {fun = id, args = [CEVar {id = srcId}, CEVar {id = dstId}]}
    in
    let body =
      foldli
        (lam acc. lam i. lam id.
          CSIf {
            cond = bop (COEq ()) (var iId) (CEInt {i = i}),
            thn = [CSRet {val = Some (bop (COEq ()) (transpApp id) (CEFloat {f = 0.0}))}],
            els = [acc] })
        (CSRet {val = Some (CEInt {i = 0})}) transpNames
    in
    let stateTy = CTyVar {id = uint32} in
    let top = CTFun {
      ret = CTyInt (), id = nameNoSym "is_predecessor",
      params = [(stateTy, srcId), (stateTy, dstId), (CTyInt (), iId)],
      body = [body]
    } in
    {annotations = [CuADevice ()], top = top}

  sem buildPredecessorProgram : String -> String
  sem buildPredecessorProgram =
  | cuCode ->
    let tempDir = sysTempDirMake () in
    -- Write the complete CUDA program to a file.
    let srcPath = join [tempDir, "/preds.cu"] in
    writeFile srcPath cuCode;
    tempDir

  sem runPredecessorProgram : TrellisOptions -> String -> TModel -> [Int]
  sem runPredecessorProgram options tempDir =
  | model ->
    let nstates = int2string (cardinalityType model.stateType) in
    let ncases = int2string (length model.transition.cases) in
    let pythonRunner = concat trellisSrcLoc "skeleton/pred-run.py" in
    let r =
      sysRunCommand ["python3", pythonRunner, nstates, ncases] "" tempDir
    in
    if eqi r.returncode 0 then
      let predsSrc = join [tempDir, "/pred*.npy"] in
      let predsDstDir = options.outputDir in
      sysMoveFile predsSrc predsDstDir;
      sysDeleteDir tempDir;
      map
        (lam s. string2int (strTrim s))
        (strSplit "\n" (strTrim r.stdout))
    else
      let msg = join [
        "Internal error: Failed when pre-computing the predecessors\n",
        "  stdout: ", r.stdout, "\n",
        "  stderr: ", r.stderr
      ] in
      error msg
end

lang TrellisCudaCompile =
  TrellisCudaCompileTypeDefs + TrellisCudaConstantDefs +
  TrellisCudaConstantDefs + TrellisCudaTableDefinitions +
  TrellisCudaProbabilityFunction + TrellisCudaHMM + TrellisEncode +
  TrellisModelMergeSubsequentOperations + TrellisGroupConstraints +
  TrellisCudaComputePredecessors

  -- NOTE(larshum, 2024-04-26): We assume the type of the state was declared
  -- as a tuple, or that it has been transformed to one by the compiler.
  sem extractStateComponentTypes : TType -> [TType]
  sem extractStateComponentTypes =
  | TTuple {tys = tys} -> tys
  | _ -> error "Internal compiler error: state type is not a tuple"

  sem compileToCuda : TrellisOptions -> Map Name TExpr -> TModel
                   -> Option [ConstraintRepr] -> (CuCompileEnv, CuProgram)
  sem compileToCuda options syntheticTables model =
  | optRepr ->
    let env : CuCompileEnv = {
      constraints = [], constraintGroups = [], transFunNames = [],
      tables = model.tables, opts = options, numPreds = [],
      stateType = extractStateComponentTypes model.stateType,
      precomputedPredecessors = optionIsNone optRepr
    } in

    let env =
      match optRepr with Some constraints then
        let env = {env with constraints = constraints} in

        -- Group constraints that are disjoint but cover all to-states to enable
        -- optimizations later on in the compiler.
        let env = groupMutuallyExclusiveConstraints env in

        -- Compute the maximum number of predecessors based on how the constraints
        -- were grouped.
        {env with numPreds = [computeMaxPredecessors env.constraintGroups env.constraints]}
      else
        env
    in

    -- Merges operations on subseqent components of the same state or output
    -- among the conditions of a set constraint.
    let model = mergeSubsequentOperationsModel model in

    -- Converts all references to components of a state or output to their
    -- corresponding operations on the encoded integer representation.
    let model = encodeStateOperations env.opts model in

    let env =
      if env.precomputedPredecessors then
        {env with numPreds = computePredecessors env model}
      else env
    in

    -- Generate type definitions for sized integer types and the sizes of
    -- integers used to encode states, probabilities, and observations, based
    -- on the model. We define the sized integer types manually to avoid having
    -- to include cstdint, as this is tricky to get right using NVRTC.
    let tyDefs = generateTypeDefines env model in

    -- Generates definitions of constants based on command-line options and
    -- properties of the current model.
    let constDefs = generateModelConstantDefines env model in

    -- Generates code declaring the tables of the model and code for copying
    -- them to constant memory on the GPU.
    let modelTableDefs = generateModelTableCode env syntheticTables model in

    -- Generates the probability functions based on the model.
    match generateProbabilityFunctions env model.initial model.output model.transition
    with (env, probFunDefs) in

    -- Generates algorithm-specific functions for the Forward and Viterbi
    -- algorithms, either using the predecessor analysis results or by
    -- performing lookups in arrays if precomputing the predecessors.
    let predFunDefs = generatePredecessorFunctions env in

    let prog = {
      includes = ["<algorithm>", "<cstdint>", "<cstdio>"],
      tops = join [tyDefs, constDefs, modelTableDefs, probFunDefs, predFunDefs]
    } in
    (env, prog)
end
